\section{SAT}
\label{sec:sat}

\subsection{MiniSat}
\label{sec:minisat}

Minisat é um minimalistico, open-source resolvedor de problemas de satisfatibilidade booleana (SAT), desenvolvido para 
ajudar pesquisadores e desenvolvedores a começarem desenvolvimento em SAT's. Seu funcionamento é basiado em backtracking
por conflito de analises e aprendisado.

Os componentes do resolvedor do MiniSat podem ser divididos conceptualmente em três categorias. A primeira é a representação,
de alguma forma a instância do SAT deve ser representada por estruturas de dados. A segunda é a inferência, o resolvedor necessita
de mecanismos para computar e propagar as implicações do estado atual de informações. A terceira é pesquisa, geralmente combinado
com inferência, pesquisa é necessária para encontrar informação.

Para realizar pesquisas, assunções são feitas, atribuindo valores a variáveis selecionadas até que a propagação detecte um conflito.
Nesse ponto uma cláusula conflito é construída e adicionada ao problema SAT.

O MiniSat utiliza como base o algoritmo de pesquisa de Davis-Putman-Longemann-Loveland (DPLL), baseado em 
retrocesso (backtracking), que serve para decidir a satisfatibilidade de formulas da logica proposicional em formula normal
conjutiva, ou seja, para resolver problemas SAT.

O algoritimo de backtracking escolhe um literal $\Phi$ e lhe da o valor de \texttt{TRUE}, simplificando a formula e depois
recursivamente checando se a formula simplificada é satisfatível. Caso seja, a formula original também é
satisfatível, caso contrario, a mesma checagem recursiva é feita mas dando o valor \texttt{FALSE} dado ao literal $\phi$.
Assim dividindo o problema em dois, simplificados, sub-problemas.

Se uma clausula contem apenas um literal, então essa clausula so pode ser satisfeita se for associado o valor
\texttt{TRUE} ao literal. Quando uma variável proposicional ocorre com apenas uma polaridade, ela é chamada de pura. Variáveis puras
podem ser associadas de um jeito onde toda clausula que as contem resultam em \texttt{TRUE}, logo tais clausulas podem
ser deletadas da busca.
\begin{lstlisting}
  funcao DPLL($\Phi$, u)
   se todas as clausulas de Y forem verdadeiras 
       entao retorne TRUE;
       
   se alguma clausula de Y for falsa
       entao retorne FALSE;
       
   se ocorrer uma clausula unitaria c em Y
       entao retorne DPLL(atribuicao(c,Y), (u and c));
       
   se ocorrer um literal puro c em Y
       entao retorne DPLL(atribuicao(c,Y), (u and c));
       
   c := escolha_literal(Y);
   
   retorne DPLL(atribuicao(c,Y), (u and c)) ou
           DPLL(atribuicao(-c,Y), (u and -c));
\end{lstlisting}

 No pseudocódigo acima, \texttt{atribuição(c, $\Phi$)} é uma função que retorna uma fórmula obtida pela substituição de cada ocorrência
 de \texttt{c} por \texttt{TRUE}, e cada ocorrência do literal oposto por falso na fórmula \texttt{Y}, e em seguida, simplificando a fórmula resultante.
 A função DPLL do pseudocódigo retorna verdadeiro se a atribuição final satisfaz a fórmula ou falso se tal atribuição não satisfaz 
 a fórmula. Em uma implementação real, a atribuição satisfatível também é retornada no caso de sucesso (esta foi omitida para maior clareza).